<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
  <title>トタンガラガラ</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
  <style>
    body { margin:0; background:#0c0f14; }
    canvas { display:block; margin:auto; touch-action:none; }
  </style>
</head>
<body>

<script>
class GaragaraScene extends Phaser.Scene {
  constructor(){ super('main'); }

  create(){
    this.graphics = this.add.graphics();
    this.scrollX = 0;

    // ==== AudioContext をタッチ操作で初期化 ====
    this.audioCtx = null;
    this.noiseBuf = null;
    this.resumePromise = null;
    this.hasInteracted = false;
    this.pointerThreshold = 14;
    this.lastPointerDiff = null;
    this.lastNoiseTime = 0;

    this.input.on('pointerdown', pointer=>{
      this.hasInteracted = true;
      this.lastPointerDiff = null;
      this.ensureAudio();
      this.tryPlayTinNoise(pointer, true);
    });

    this.input.on('pointerup', ()=>{
      this.lastPointerDiff = null;
    });
  }

  update(){
    this.scrollX += 2; // トタンが流れる速度
    this.drawTin();
    this.trackPointer();
  }

  drawTin(){
    this.graphics.clear();
    this.graphics.lineStyle(2, 0x999999, 1);
    const baseY = this.sys.game.config.height * 0.6;
    for (let i=0;i<this.sys.game.config.width;i+=6){
      const yy = baseY + Math.sin((i+this.scrollX)/15)*8;
      this.graphics.lineBetween(i, yy, i+6, yy);
    }
  }

  playNoise(){
    this.ensureAudio().then(()=>{
      if (!this.audioCtx || !this.noiseBuf || this.audioCtx.state !== 'running') return;
      const src = this.audioCtx.createBufferSource();
      src.buffer = this.noiseBuf;
      const gain = this.audioCtx.createGain();
      gain.gain.value = 0.3;
      src.connect(gain).connect(this.audioCtx.destination);
      const duration = 0.05;
      try {
        src.start(0);
        src.stop(this.audioCtx.currentTime + duration);
      } catch (err) {
        try {
          src.start(0, 0, duration);
        } catch(_){}
      }
    }).catch(()=>{});
  }

  ensureAudio(){
    if (!this.audioCtx) {
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      if (!AudioCtx) return Promise.resolve();
      this.audioCtx = new AudioCtx();
      const buffer = this.audioCtx.createBuffer(1, this.audioCtx.sampleRate, this.audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for(let i=0;i<data.length;i++) data[i]=(Math.random()*2-1)*0.25;
      this.noiseBuf = buffer;
    }

    if (this.audioCtx.state === 'running') {
      return Promise.resolve();
    }

    if (!this.resumePromise) {
      this.resumePromise = this.audioCtx.resume()
        .catch(err=>{
          this.resumePromise = null;
          throw err;
        })
        .then(()=>{
          this.resumePromise = null;
        });
      }

    return this.resumePromise;
  }

  trackPointer(){
    const pointer = this.input.activePointer;
    if (!pointer) return;
    this.tryPlayTinNoise(pointer);
  }

  tryPlayTinNoise(pointer, force=false){
    if (!pointer) return;

    if (!this.hasInteracted) return;

    const width = this.sys.game.config.width;
    const height = this.sys.game.config.height;
    if (pointer.x < 0 || pointer.x > width || pointer.y < 0 || pointer.y > height) {
      this.lastPointerDiff = null;
      return;
    }

    if (pointer.pointerType !== 'mouse' && !pointer.isDown) {
      this.lastPointerDiff = null;
      return;
    }

    const waveY = this.getTinY(pointer.x);
    const diff = pointer.y - waveY;
    const threshold = this.pointerThreshold;
    const now = this.time.now;

    const lastDiff = this.lastPointerDiff;
    let shouldPlay = false;

    if (force) {
      shouldPlay = Math.abs(diff) <= threshold;
    } else if (lastDiff !== null) {
      const crossed = lastDiff * diff <= 0;
      const within = Math.abs(diff) <= threshold;
      const wasWithin = Math.abs(lastDiff) <= threshold;
      shouldPlay = (crossed && (within || wasWithin)) || (!wasWithin && within);
    } else {
      shouldPlay = Math.abs(diff) <= threshold;
    }

    if (shouldPlay && now - this.lastNoiseTime > 60) {
      this.lastNoiseTime = now;
      this.playNoise();
    }

    this.lastPointerDiff = diff;
  }

  getTinY(x){
    const baseY = this.sys.game.config.height * 0.6;
    return baseY + Math.sin((x + this.scrollX)/15)*8;
  }
}

const config = {
  type: Phaser.AUTO,
  width: window.innerWidth,
  height: window.innerHeight,
  backgroundColor: '#0c0f14',
  scene: [GaragaraScene]
};

new Phaser.Game(config);
</script>

</body>
</html>
